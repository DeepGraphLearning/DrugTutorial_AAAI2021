

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Batch Irregular Structures &mdash; Drugdiscovery 0.1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Debug Your Models" href="debug.html" />
    <link rel="prev" title="Graph Neural Network Layers" href="layer.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Drugdiscovery
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quick_start.html">Quick Start</a></li>
</ul>
<p class="caption"><span class="caption-text">Benchmark</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../benchmark/property_prediction.html">Molecule Property Prediction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmark/generation.html">Graph Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmark/retrosynthesis.html">Retrosynthesis</a></li>
</ul>
<p class="caption"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/property_prediction.html">Molecule Property Prediction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/generation.html">Molecule Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/retrosynthesis.html">Retrosynthesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/link_prediction.html">Link Prediction</a></li>
</ul>
<p class="caption"><span class="caption-text">Notes</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="graph.html">Graph Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="layer.html">Graph Neural Network Layers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Batch Irregular Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#variadic-input">Variadic Input</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variadic-output">Variadic Output</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="debug.html">Debug Your Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="extension.html">Custom Extensions</a></li>
</ul>
<p class="caption"><span class="caption-text">Package Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/core.html">drugdiscovery.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/data.html">drugdiscovery.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/datasets.html">drugdiscovery.datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/layers.html">drugdiscovery.layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/models.html">drugdiscovery.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/tasks.html">drugdiscovery.tasks</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Drugdiscovery</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Batch Irregular Structures</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/notes/variadic.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="batch-irregular-structures">
<h1>Batch Irregular Structures<a class="headerlink" href="#batch-irregular-structures" title="Permalink to this headline">¶</a></h1>
<p>Unlike images, text and audio, graphs usually have irregular structures, which
makes them hard to batch in tensor frameworks. Many existing implementations use
padding to convert graphs into dense grid structures, which costs much unnecessary
computation and memory.</p>
<p>In Drugdiscovery, we develop a more intuitive and efficient solution based on
variadic functions. The variadic functions can directly operate on sparse irregular
inputs or outputs.</p>
<div class="section" id="variadic-input">
<h2>Variadic Input<a class="headerlink" href="#variadic-input" title="Permalink to this headline">¶</a></h2>
<p>Here we show how to apply functions to variadic inputs.</p>
<p>Generally, a batch of <span class="math notranslate nohighlight">\(n\)</span> variadic tensors can be represented by a value
tensor and a size tensor. The value tensor is a concatenation of all variadic
tensors along the variadic axis, while the size tensor indicates how big each
variadic tensor is.</p>
<p>Let’s first create a batch of 1D variadic samples.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">,)))</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">])</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/variadic_tensor.png"><img alt="../_images/variadic_tensor.png" class="align-center" src="../_images/variadic_tensor.png" style="width: 60%;" /></a>
<p>We apply variadic functions to compute the sum, max and top-k values for each
sample.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">drugdiscovery.layers</span> <span class="kn">import</span> <span class="n">functional</span>

<span class="nb">sum</span> <span class="o">=</span> <span class="n">functional</span><span class="o">.</span><span class="n">variadic_sum</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
<span class="nb">max</span> <span class="o">=</span> <span class="n">functional</span><span class="o">.</span><span class="n">variadic_max</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">top3_value</span><span class="p">,</span> <span class="n">top3_index</span> <span class="o">=</span> <span class="n">functional</span><span class="o">.</span><span class="n">variadic_topk</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Note <a class="reference internal" href="../api/layers.html#drugdiscovery.layers.functional.variadic_topk" title="drugdiscovery.layers.functional.variadic_topk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">variadic_topk</span></code></a> accepts
samples smaller than <span class="math notranslate nohighlight">\(k\)</span>. In this case, it will fill the output with the
smallest element from that sample.</p>
<a class="reference internal image-reference" href="../_images/variadic_func_result.png"><img alt="../_images/variadic_func_result.png" class="align-center" src="../_images/variadic_func_result.png" style="width: 88%;" /></a>
<p>Mathematically, these functions can be viewed as performing the operation over
each sample with a for loop. For example, the variadic sum is equivalent to the
following logic.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sums</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">:</span>
    <span class="n">sums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="nb">sum</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">sums</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In spite of the same logic, variadic functions is much faster than for loops
on GPUs (typically <span class="math notranslate nohighlight">\(\text{batch size}\times\)</span> faster). Use variadic functions
instead of for loops whenever possible.</p>
</div>
<p>Many operations in graph representation learning can be implemented by variadic
functions. For example,</p>
<ol class="arabic simple">
<li><p>Infer graph-level representations from node-/edge-level representations.</p></li>
<li><p>Perform classification over nodes/edges.</p></li>
</ol>
<p>Here we demonstrate how to perform classification over nodes. We create a toy
task, where the model needs to predict the heaviest atom of each molecule. Note
that node attributes form variadic tensors with <code class="docutils literal notranslate"><span class="pre">num_nodes</span></code> from the same graph.
Therefore, we can use <a class="reference internal" href="../api/layers.html#drugdiscovery.layers.functional.variadic_max" title="drugdiscovery.layers.functional.variadic_max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">variadic_max</span></code></a>
to get our ground truth.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">drugdiscovery</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">metrics</span>

<span class="n">smiles_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;CC(=C)C#N&quot;</span><span class="p">,</span> <span class="s2">&quot;CCNC(=S)NCC&quot;</span><span class="p">,</span> <span class="s2">&quot;BrC1=CC=C(Br)C=C1&quot;</span><span class="p">]</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">PackedMolecule</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span><span class="n">smiles_list</span><span class="p">)</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">functional</span><span class="o">.</span><span class="n">variadic_max</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">atom_type</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Naturally, the prediction over nodes also forms a variadic tensor with <code class="docutils literal notranslate"><span class="pre">num_nodes</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">GCN</span><span class="p">(</span><span class="n">input_dim</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">node_feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">hidden_dims</span><span class="o">=</span><span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">feature</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">node_feature</span><span class="o">.</span><span class="n">float</span><span class="p">())</span>
<span class="n">pred</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s2">&quot;node_feature&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">pred_prob</span><span class="p">,</span> <span class="n">pred_index</span> <span class="o">=</span> <span class="n">functional</span><span class="o">.</span><span class="n">variadic_max</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">functional</span><span class="o">.</span><span class="n">variadic_cross_entropy</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
<span class="n">accuracy</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">variadic_accuracy</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../api/layers.html#drugdiscovery.layers.functional.variadic_sum" title="drugdiscovery.layers.functional.variadic_sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">variadic_sum</span></code></a>,
<a class="reference internal" href="../api/layers.html#drugdiscovery.layers.functional.variadic_mean" title="drugdiscovery.layers.functional.variadic_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">variadic_mean</span></code></a>,
<a class="reference internal" href="../api/layers.html#drugdiscovery.layers.functional.variadic_max" title="drugdiscovery.layers.functional.variadic_max"><code class="xref py py-func docutils literal notranslate"><span class="pre">variadic_max</span></code></a>,
<a class="reference internal" href="../api/layers.html#drugdiscovery.layers.functional.variadic_topk" title="drugdiscovery.layers.functional.variadic_topk"><code class="xref py py-func docutils literal notranslate"><span class="pre">variadic_topk</span></code></a>,
<a class="reference internal" href="../api/layers.html#drugdiscovery.layers.functional.variadic_log_softmax" title="drugdiscovery.layers.functional.variadic_log_softmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">variadic_log_softmax</span></code></a>,
<a class="reference internal" href="../api/layers.html#drugdiscovery.layers.functional.variadic_cross_entropy" title="drugdiscovery.layers.functional.variadic_cross_entropy"><code class="xref py py-func docutils literal notranslate"><span class="pre">variadic_cross_entropy</span></code></a>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">variadic_accuracy</span></code></p>
</div>
</div>
<div class="section" id="variadic-output">
<h2>Variadic Output<a class="headerlink" href="#variadic-output" title="Permalink to this headline">¶</a></h2>
<p>In some cases, we also need to write functions that produce variadic outputs. A
typical example is autoregressive generation, where we need to generate all
node/edge prefixes of a graph. When this operation is batched, we need to output
variadic numbers of graphs for different input graphs.</p>
<p>Here we show how to generate edge prefixes for a batch of graphs in Drugdiscovery.
First, let’s prepare a batch of two graphs.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edge_list</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="n">graph1</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">num_node</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">edge_list</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="n">graph2</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">num_node</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">pack</span><span class="p">([</span><span class="n">graph1</span><span class="p">,</span> <span class="n">graph2</span><span class="p">])</span>
<span class="k">with</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">():</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/autoregressive_input.png"><img alt="../_images/autoregressive_input.png" class="align-center" src="../_images/autoregressive_input.png" style="width: 66%;" /></a>
<p>The generation of edge prefixes consists 3 steps.</p>
<ol class="arabic simple">
<li><p>Construct an extended batch with enough copies for each graph.</p></li>
<li><p>Apply an edge mask over the batch.</p></li>
<li><p>Remove excess or invalid graphs.</p></li>
</ol>
<p>The first step can be implemented through
<a class="reference internal" href="../api/data.html#drugdiscovery.data.Graph.repeat" title="drugdiscovery.data.Graph.repeat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.repeat</span></code></a>. For the following steps, we
define an auxiliary function <code class="docutils literal notranslate"><span class="pre">all_prefix_slice</span></code>. This function takes in a size
tensor and desired prefix lengths, and outputs <span class="math notranslate nohighlight">\(n*l\)</span> prefix slices for the
extended batch, where <span class="math notranslate nohighlight">\(n\)</span> is the batch size and <span class="math notranslate nohighlight">\(l\)</span> is the number of
prefix lengths.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all_prefix_slice</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">lengths</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">cum_sizes</span> <span class="o">=</span> <span class="n">sizes</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">starts</span> <span class="o">=</span> <span class="n">cum_sizes</span> <span class="o">-</span> <span class="n">sizes</span>
    <span class="k">if</span> <span class="n">lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="n">sizes</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">sizes</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="n">pack_offsets</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">sizes</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_cum_xs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">starts</span> <span class="o">=</span> <span class="n">starts</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack_offsets</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="n">lengths</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sizes</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">lengths</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">sizes</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="n">starts</span> <span class="o">+</span> <span class="n">lengths</span>

    <span class="n">starts</span> <span class="o">=</span> <span class="n">starts</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="n">ends</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">,</span> <span class="n">valid</span>

<span class="n">lengths</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">num_edges</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">num_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
<span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="n">all_prefix_slice</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">num_edges</span><span class="p">,</span> <span class="n">lengths</span><span class="p">)</span>
</pre></div>
</div>
<p>The slices are visualized as follows. Two colors correspond to two input graphs.</p>
<a class="reference internal image-reference" href="../_images/autoregressive_slice.png"><img alt="../_images/autoregressive_slice.png" class="align-center" src="../_images/autoregressive_slice.png" style="width: 55%;" /></a>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_length</span><span class="p">)</span> <span class="c1"># step 1</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">functional</span><span class="o">.</span><span class="n">multi_slice_mask</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">)</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edge_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># step 2</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="c1"># step 3</span>
</pre></div>
</div>
<p>The output batch is</p>
<img alt="../_images/autoregressive_output.png" src="../_images/autoregressive_output.png" />
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="debug.html" class="btn btn-neutral float-right" title="Debug Your Models" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="layer.html" class="btn btn-neutral float-left" title="Graph Neural Network Layers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, MilaGraph Group

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>